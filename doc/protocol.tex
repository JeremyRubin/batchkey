\documentclass{article}

\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amssymb}

\author{Jeremy Rubin}
\title{Efficiently Batch Generating N-of-N ECDSA Threshold Single Signatures}


\newcommand{\addencrypt}{\varepsilon_{+}}
\newcommand{\adddecrypt}{\delta_{+}}
\newcommand{\mulencrypt}{\varepsilon_{*}}
\newcommand{\muldecrypt}{\delta_{*}}
\newcommand{\mulOT}{\pi_{*}}

\begin{document}
\maketitle

\section{Assumptions}


\subsection{Elliptic Curves}

Assume a curve with a base point 
Let $$(x_G, y_G) = G$$
and order $N$.

\subsection{Additive Homomorphic Encryption}

Assume a protocol which encrypts values to ciphertexts under a given key that may be added
and the sum decrypted without revealing the summands.

We denote this

$$\addencrypt(a) + \addencrypt(b) = \addencrypt(a+b)$$
$$ a = \adddecrypt(\addencrypt(a)) $$

We also assume that such a scheme can be secret-shared so that we may use it to decrypt only with the approval of several parties.


\subsection{Oblivious Transfer Multiplication}

We also assume a protocol which allows us to compute, across two parties each knowing $a$ and $b$, $a\cdot b$ without either party learning $a$, $b$, or $ab$, but learning a share $s_1, s_2$ of $ab$ each such that $s_1+s_2 = ab$.

We denote this scheme $\mulOT(a,b) = \tau_1 + \tau_2$. 

\section{Protocol}

\subsection{Reusable Nonce Generation}
Let each party generate a secret $k_i$

$$k_i \leftarrow [1, N-1]$$

Each party should also compute the multiplicative modular inverse

Let $$q_i \leftarrow k_i^{-1} \mod N$$


All parties compute the group element corresponding to the nonce without revealing their nonce.
$$(x_0, y_0) = K \times G = \left(\prod_{i=1}^n  k_i\right) \times G = \left(\prod_{i=2}^n k_i\right) k_1 \times G = \ldots$$

If needed, in order to prevent an attacker from chooser their nonce after observing the partial product, all participants can pre-share
$H(k_i \times G)$. Then, they can prove that they valdly multiplied their previously chosen nonce by checking the value of 
$K\times G^{n-1}$ corresponds with the product of all the hash preimages.

Let $$ r = x_0 \mod N $$

Next, we compute the inverse as a secret share using Oblivious Transfer Multiplication.
\begin{equation*}
    \begin{split}
        Q = K^{-1} &= \prod_{i=1}^n q_i \\
        &= q_1\cdot q_2  \prod_{i=3}^n q_i\\ 
        &= \mulOT(q_1, q_2) \prod_{i=3}^n q_i \\
        &= (\tau_1 + \tau_2) \prod_{i=3}^n q_i \\
        &= \mulOT(\tau_1, q_3) \prod_{i=4}^n q_i + \mulOT(\tau_2, q_3) \prod_{i=4}^n q_i \\
        &= (\gamma_1 + \gamma_2) \prod_{i=4}^n q_i + (\gamma_3 + \gamma_4) \prod_{i=4}^n q_i\\
        &= \gamma_1  \prod_{i=4}^n q_i+ \gamma_3  \prod_{i=4}^n q_i+ (\gamma_2 + \gamma_4) \prod_{i=4}^n q_i \\
        &\cdots \\
        &= \mu_1 + \mu_2 \ldots \mu_n
    \end{split}
\end{equation*}
 By proprerly ordering terms and aggregating shares known by a single party, we keep the total number of interactions to $O(n^2)$. Fortunately, much of this computation is parallelizable, so the total asymptotic time should be closer to $O(n)$ as we have $n$ participants.


Note that in effect, $r$ is the aggregate public key and $\mu_i$ is a secret key known only to each participant.


Note that additional nonces may be cheaply generated by
participants by generating securely among all participants (perhaps using fair
coin flipping) a known $k'q' = 1 \mod N$ and multiplying $k'(K\times G)$ to get
$r'$ and each share of $Q$ by $q'$. This assists in improving privacy of the
protocol, but does not allow for keys to be reused.


\subsection{Single Use Key Generation}

First, all parties generate a public key private key pair denoted.

Let $$\alpha_i \leftarrow [1, N-1]$$
Let $$\beta_i \leftarrow \alpha_i \times G$$

Next, parties sum their public keys to produce an aggregate key $B$.

Let $$ B = \sum\limits_{i = 1}^n \beta_i = \left(\sum\limits_{i=1}^n \alpha_i\right) \times G$$


Then, the parties homomorphically add their keys to produce an aggregate secret
key known to no individual party.

Let $$\addencrypt(A) = \sum\limits_{i=1}^n \addencrypt(\alpha_i)$$

\subsection{Single Signing}

We denote the desired message to be signed as $H(B || \ldots)$. This is to
emphasize that the message may be arbitrary, and it may include B (thereby
preventing using public key recovery schemes).


First, using the encrypted single use private key, we compute the signatures
internal $I$ value. Because $r$ is a scalar, we can compute multiplication
through repeated addition (using standard well known optimizations) if our
homomorphic scheme does not permit  more efficient computation.
\begin{equation*}
    \begin{split}
        \addencrypt(I) & = r\addencrypt(A) + H(B || \ldots) \\
        & = \sum_{1}^r \addencrypt(A) + H(B || \ldots) \\
        & = \addencrypt(r \cdot A) + H(B || \ldots) \\
        &= \addencrypt(r\cdot A) + \addencrypt(H(B || \ldots)) \\
        &= \addencrypt(r\cdot A + H(B || \ldots)) 
    \end{split}
\end{equation*}


Next, we compute the signature's s value by multiplying Q and I. Because we
known additive shares of $Q$, $\mu_i$, we may have each party locally compute
the scalar multiplication, sum the results, and then decrypt.

Let $$ \addencrypt(s) = Q \cdot \addencrypt(I) 
    = \left( \sum_{i=1}^n \mu_i \right) \cdot \addencrypt(I)
    = \sum_{i=1}^n \left( \mu_i \cdot \addencrypt(I)\right)
    = \sum_{i=1}^n \addencrypt(\mu_i I)
    = \addencrypt(Q I) $$

Let $$ s = \adddecrypt(\addencrypt(s)) \mod N$$


Now, we verify $(r,s)$ as a standard-conforming ECDSA against the public key
$B$ for message $H(B || \ldots)$.



\subsection{Batch Signing}

If we run a single round of Reusable Nonce Generation, we may run $P$ rounds of
Single Use Key Generation and Single Signing. Provided all ECDSA verifications
succeed, we have successfully signed $P$ messages for $P$ unique keys that are
unforgeable by any $t < n$ party

\end{document}
